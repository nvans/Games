/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/


// #define	  stop __asm __nop
#include <iostream>
#include <ctime>

#define IARR_LENGTH(arr) (sizeof(arr) / sizeof(int))
#define DARR_LENGTH(arr) (sizeof(arr) / sizeof(double))

int main()
{
	
	///////////////////////////////////////////////////////////////
	//			Встроенные массивы                               //
	///////////////////////////////////////////////////////////////

		//Задание 1. Объявите трехмерный массив и сформируйте указанные
		//значения элементов следующим образом:
		//а) проинициализируйте массив при объявлении
	{
		int iArr[3][3][3] =
		{
			{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
			{{2, 2, 2}, {2, 2, 2}, {2, 2, 2}},
			{{3, 3, 3}, {3, 3, 3}, {3, 3 ,3}}
		};

		std::cout << "";
	}
	//б) объявите неинициализированный массив и присвойте значения элементам
	//	с помощью кода
	//					 |--------|		
	//				   / |3  3  3 |		
	//    			 |---------|3 |
	//			   / | 2  2  2 |3 |
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|
	//Средствами отладчика проверьте правильность Вашего решения.
	{
		int iArr[3][3][3];

		int *pArr = &iArr[0][0][0];		// указатель на начало массива
		int initValue = 0;

		for (int i = 0; i < IARR_LENGTH(iArr); i++) {

			if (!(i % 9)) {		// условие заполнения слоя из 9 элементов
				initValue++;
			}

			*pArr++ = initValue;
		}

		pArr = nullptr;
		std::cout << "";


		//в) найдите сумму элементов массива
		pArr = &iArr[0][0][0];
		int sum = 0;

		for (int i = 0; i < IARR_LENGTH(iArr); i++) {

			sum += *pArr;
			pArr++;

		}

		std::cout << "Sum = " << sum << std::endl;

		//stop
		std::cout << "";
	}
	//г) проинициализируйте массив при объявлении:
	//					 |--------|		
	//				   / |3  0  0 |		
	//    			 |---------|0 |
	//			   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__| 
	//			  | 0  0  0 | /
	//			  |_________|

	{
		int iArr[3][3][3] =
		{
			{{1}},
			{{2}},
			{{3}}
		};

		std::cout << "";
	}

	//д) Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.
	{
		// двумерный  массив
		char ar1[3][8] = {
			"String1",
			"String2",
			"String3"
		};

		// Символ S изменится
		ar1[0][0] = 'Q';

		// массив указателей
		char* ar2[] = {
			"String1",
			"String2",
			"String3"
		};

		// произойдёт ошибка времени выполнения, т.к. строка расположена в read-only области памяти
//		ar2[0][0] = 'Q';

		std::cout << "";
	}



	///////////////////////////////////////////////////////////////
	//			Динамическое выделение памяти                    //
	///////////////////////////////////////////////////////////////
		//Задание2. Создайте динамический двухмерный массив с размерностями,
		//вычисляемыми в процессе выполнения программы - N*M.
		//Задайте значения элементов помощью генератора случайных чисел.
		//Найдите  сумму элементов.
		//Подсказка 1: для генерации случайных чисел используйте функцию
		//стандартной библиотеки - rand() (<cstdlib>)
		//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
		//чисел являются «псевдослучайными», то есть при двух последовательных запусках
		//приложения Вы получаете две одинаковые последовательности значений.
		//Для того чтобы генерируемые "случайные" значения были разными при каждом 
		//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
		//и time() (<ctime>).
		//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
		//Функция time() задает эту точку отсчета, считывая текущее время
	{
		//srand( time( 0 ) );
		srand(time(0));

		size_t N, M;
		std::cin >> N >> M;

		// массив указателей на строки массива
		int** arr = new int*[N];

		// выделение памяти для строк
		for (int i = 0; i < N; i++) {
			arr[i] = new int[M];
		}

		// инициализация массива случайными значениями в диапазоне [0,9]
		std::cout << "Array: " << std::endl;

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				arr[i][j] = (rand() % 10);
				std::cout << arr[i][j] << " ";
			}
			std::cout << std::endl;
		}

		std::cout << "";
		//Задание2а. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"
		std::cout << "Sorted array: " << std::endl;

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {

				int min = j;

				for (int k = j + 1; k < M; k++) {
					if (arr[i][k] < arr[i][min]) {
						min = k;
					}
				}

				int tmp = arr[i][min];
				arr[i][min] = arr[i][j];
				arr[i][j] = tmp;
			}
		}

		// вывод отсортированного массива
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				std::cout << arr[i][j] << " ";
			}
			std::cout << std::endl;
		}

		//Задание2б. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива  
		//равным среднему значению элементов i-ой строки
		//двухмерного массива
		float* average = new float[N];

		for (int i = 0; i < N; i++) {

			int sum = 0;

			for (int j = 0; j < M; j++) {
				sum += arr[i][j];
			}

			average[i] = (sum != 0) ? (static_cast<float>(sum) / M) : 0;
		}

		std::cout << "Array of average: " << std::endl;
		for (int i = 0; i < N; i++) {
			std::cout << average[i] << " ";
		}
		std::cout << std::endl;

		//Подсказка - не забудьте освободить память!
		// освобождение памяти массива средних значений строк
		delete[] average;

		// освобождение памяти элементов строк массива
		for (int i = 0; i < N; i++) {
			delete arr[i];
		}

		// освобождение памяти массива строк
		delete[] arr;

		std::cout << "";
	}



	/////////////////////////////////////////////////////////////////////
	//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
	//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
	//упорядочивая полученное значение по возрастанию
	{
		const int NN = 3;
		int arr[NN] = {};
		int digit = 0;

		for (int i = 0; i < NN; i++) {
			std::cin >> digit;

			// при вводе первой цифры сразу записываем
			// её в массив в позицию 0 и считываем следующую
			if (i == 0) {
				arr[0] = digit;
				continue;
			}

			int j;

			for (j = 0; j < i; j++) {
				// запоминаем позицию для вставки
				if (digit < arr[j]) {
					break;
				}
			}

			// сдвигаем массив
			for (int k = i; k > j; k--) {
				arr[k] = arr[k - 1];
			}

			// вставляем цифру
			arr[j] = digit;


		}

		std::cout << "Array 3a: ";
		for (int i = 0; i < NN; i++) {
			std::cout << arr[i] << " ";
		}

		std::cout << std::endl;

	}
	//б) Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:очередное значение
	//вводится в массив только при условии, что там еще такого нет (то есть 
	//дубли игнорируются
	{
		const int NN = 3;
		int arr[NN] = {};
		int digit = 0;

		for (int i = 0; i < NN; i++) {

			bool isEqual = false;

			std::cin >> digit;

			// при вводе первой цифры сразу записываем
			// её в массив в позицию 0 и считываем следующую
			if (i == 0) {
				arr[0] = digit;
				continue;
			}

			int j;

			for (j = 0; j < i; j++) {
				// запоминаем позицию для вставки
				if (digit < arr[j]) {
					break;
				}
				// если цифра уже есть, то устанавливаем признак присутствия в массиве
				else if (digit == arr[j]) {
					isEqual = true;
					break;
				}

			}

			if (isEqual) {
				i--;
				continue;
			}

			// сдвигаем массив
			for (int k = i; k > j; k--) {
				arr[k] = arr[k - 1];
			}

			// вставляем цифру
			arr[j] = digit;

		}

		// вывод массива в консоль
		std::cout << "Array 3b: ";
		for (int i = 0; i < NN; i++) {
			std::cout << arr[i] << " ";
		}

		std::cout << std::endl;
	}



	///////////////////////////////////////////////////////////////////////////
	//Задание 4.С помощью данной заготовки напишите программу,
	//которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение массива (больше свободных строк нет);
	//сортировка строк в алфавитном порядке. Пояснение: крайне
	//не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти. Намного эффективнее завести массив
	//указателей на соответствующие строки и перемещать только
	//указатели.

	//Подсказка: для лексиграфического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.

	//Определите необходимые значения как константы
	//STOP_STRING  -  "*"	//признак "прекратить ввод"
	//M  -  80	//максимальный размер одной строки
	//N  -  10	//максимальное количество строк в массиве
#define STOP_STRING "*"
#define M 80
#define N 10
	{
		//Объявите двухмерный массив с именем cBuffer типа char и
		// размерностью N*M
		char cBuffer[N][M];

		//Объявите массив (с именем cPointers) указателей на строки
		//размерностью N
		char* cPointers[N] = {};

		//Цикл ввода строк:
		//а) выведите приглашение для ввода
		std::cout << "4. Enter <= 10 strings. Type * for end." << std::endl;

		int nIndex = 0;

		//б) пока не введена строка STOP_STRING или не заполнен весь массив
		while (nIndex < N) {
			//ввод строки в массив cBuffer:
			std::cin >> cBuffer[nIndex];

			//если введена строка прекращения ввода, то выйти из цикла
			if (!strcmp(cBuffer[nIndex], STOP_STRING)) {
				break;
			}

			//Присвойте элементу массива cPointers с индексом nIndex
			//указатель на строку с номером nIndex в массиве cBuffer
			cPointers[nIndex] = &cBuffer[nIndex][0];

			nIndex++;
		}


		//Выдать диагностику о том, что прием строк завершен.
		std::cout << "End of strings input." << std::endl;


		//Теперь сортируем строки:

		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания. На каждой итерации - промежуточная печать 
		//отсортированных строк
		bool isSorted = false;

		for (int i = 0; i < nIndex; i++) {
			
			if (isSorted) {
				break;
			}

			for (int j = 0; j < nIndex - 1; j++) {
				
				if (strcmp(cPointers[j], cPointers[j + 1]) > 0) {

					char* tmp = cPointers[j];
					cPointers[j] = cPointers[j + 1];
					cPointers[j + 1] = tmp;

				}
				else if(j == nIndex - 2) { // если выполняется это условие,
										   // значит строки уже отсортированы
					isSorted = true;
				}
			}

			// промежуточный вывод строк
			std::cout << "Iteration " << i << ": ";
			for (int k = 0; k < nIndex; k++) {
				std::cout << cPointers[k] << " ";
			}
			std::cout << std::endl;
		}

		std::cout << std::endl;
	}

#undef M
#undef N

	//Задание 5. Реализуйте задание №4, используя не встроенные,
	//а динамические массивы (массив?). Так как строки могут быть разной длины,
	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
	//сколько требуется для ее хранения.
	//При этом необходимые параметры (количество строк
	// сформируйте с помощью потока ввода
	{
		int nStringNumber;

		// ввод количества строк
		std::cout << "5. Enter strings number: ";
		std::cin >> nStringNumber;
			
		char** arr = new char*[nStringNumber];

	//Цикл ввода строк:
		for (int i = 0; i < nStringNumber; i++) {
			char str[80] = {};
			std::cin >> str;
			
			if (!strcmp(str, STOP_STRING)) {
				nStringNumber = i + 1;
				break;
			}

			// длина строки + 1 символ для завершающего 0
			int strSize = strlen(str) + 1;

			arr[i] = new char[strSize];
			strcpy(arr[i], str);
						
		}
		

	//Цикл сортировки строк методом "всплывающего пузырька" в
	//порядке возрастания кода первого символа
		bool isSorted = false;
		
		for (int i = 0; i < nStringNumber; i++) {
			if (isSorted) {
				break;
			}

			for (int j = 0; j < nStringNumber - 1; j++) {

				if (strcmp(arr[j], arr[j + 1]) > 0) {

					char* tmp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = tmp;

				}
				else if (j == nStringNumber - 2) {
					isSorted = true;
				}
			}

			// промежуточный вывод строк
			std::cout << "Iteration " << i << ": ";
			for (int k = 0; k < nStringNumber; k++) {
				std::cout << arr[k] << " ";
			}
			std::cout << std::endl;
		}




	//Освобождение занятой памяти:
		for (int i = 0; i < nStringNumber; i++)	{
				delete arr[i];
		}

		delete[] arr;

		std::cout << std::endl;
	}

#undef STOP_STRING

	//Задание 6. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:			     |--------|		
	//  				   / |4  4  4 |		
	//					 |--------|	4 |	
	//				   / |3  3  3 |	4 |	
	//    			 |---------|3 |   |
    //			   / | 2  2  2 |3 | /
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|

	//	стало:			     |--------|		
	//  				   / |3  3  3 |		
	//					 |--------|	3 |	
	//				   / |4  4  4 |	3 |	
	//    			 |---------|4 |   |
    //			   / | 1  1  1 |4 | /
	//			  |---------|1 |__|
	//			  | 2  2  2 |1 | /
	//			  | 2  2  2 |__| 
	//			  | 2  2  2 | /
	//			  |_________|
	{

		double dArray[4][3][3];
		double* pArr = &dArray[0][0][0];
		
		// начальное значение инициализации
		int initValue = 0;

		// инициализация массива
		for (int i = 0; i < DARR_LENGTH(dArray); i++) {
			
			if (!(i % 9)) {		// условие заполнения слоя из 9 элементов
				initValue++;
			}
			
			*pArr = initValue;
			pArr++;

		}

		// указатели на двумерные массивы
		double (*pTmp1)[3] = 0;
		double (*pTmp2)[3] = 0;
		
		int size = sizeof(dArray[0]);

		for (int i = 0; i < (sizeof(dArray[0]) / sizeof(dArray[0][0])); i += 2) {

			// выделяем память под временное хранение слоя
			double* tmp = new double[size];
			
			// копируем текущий слой в промежуточный динамический массив
			memcpy(tmp, dArray[i], size);
			
			// Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
			// ... = dArray[i];
			// ... = dArray[i + 1];
			pTmp1 = dArray[i];
			pTmp2 = dArray[i + 1];
			
			//переставляем местами элементы i-того и i+1-ого слоев
			memcpy(pTmp1, pTmp2, size);
			memcpy(pTmp2, tmp, size);

			// освобождаем память
			delete tmp;
		}
		std::cout << std::endl;
	}

	///////////////////////////////////////////////////////////////////////////
	//Задание 7а. Объявите двухмерный встроенный массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
	{
		std::cout << "7a. Array: " << std::endl;
		const int N = 5;
		const int M = 5;

		char cArr[N][M];
		// указатель для инициализации
		char* p = &cArr[0][0];
		
		//В каждой строке "сдвиньте звездочки" в начало строки, например:
		//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
		//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
		//и распечатайте массив по строкам - "постройте распределение"
		srand(time(0));
		
		for (int i = 0; i < (sizeof(cArr) / sizeof(char)); i++) {
			*p = (rand() % 2 == 0) ? '*' : '_';

			if (!(i % M)) {
				std::cout << std::endl;
			}
			std::cout << *p << " ";
			
			p++;
		}

		std::cout << std::endl << "Sorted: " << std::endl << std::endl;
		
		int pos = 0;
		int stars = 0;
		
		for (int i = 0; i < N; i++)	{
			
			// за первый проход по строке считаем количество звёзд
			for (int j = 0; j < M; j++) {
				if (cArr[i][j] == '*') {
					stars++;
				}
			}

			// за второй проход по строке расставляем символы
			if (stars)	{
				for (int j = 0; j < M; j++) {
					if (stars) {
						cArr[i][j] = '*';
						stars--;
					}
					else {
						cArr[i][j] = '_';
					}
				}
			}
		}

		for (int i = 0; i < M; i++) {
			for (int j = 0; j < N; j++) {
				std::cout << cArr[i][j] << " ";
			}
			std::cout << std::endl;
		}

		std::cout << std::endl;

	}
	// 7б. Модифицируйте предыдущее задание следующим способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"
	{
		std::cout << "7b. Array: " << std::endl;
		const int N = 5;
		const int M = 5;

		char cArr[N][M];
		// указатель для инициализации
		char* p = &cArr[0][0];

		//В каждой строке "сдвиньте звездочки" в начало строки, например:
		//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
		//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
		//и распечатайте массив по строкам - "постройте распределение"
		srand(time(0));

		for (int i = 0; i < (sizeof(cArr) / sizeof(char)); i++) {
			*p = (rand() % 2 == 0) ? '*' : '_';

			if (!(i % M)) {
				std::cout << std::endl;
			}
			std::cout << *p << " ";

			p++;
		}

		std::cout << std::endl << "Sorted: " << std::endl << std::endl;

		int pos = 0;
		int stars = 0;

		for (int i = 0; i < M; i++) {

			// за первый проход по столбцу считаем количество звёзд
			for (int j = 0; j < N; j++) {
				if (cArr[j][i] == '*') {
					stars++;
				}
			}

			// за второй проход по столбцу расставляем символы
			if (stars) {
				for (int j = N - 1; j >= 0; j--) {
					if (stars) {
						cArr[j][i] = '*';
						stars--;
					}
					else {
						cArr[j][i] = '_';
					}
				}
			}
		}

		// вывод на консоль
		for (int i = 0; i < M; i++) {
			for (int j = 0; j < N; j++) {
				std::cout << cArr[i][j] << " ";
			}
			std::cout << std::endl;
		}

		std::cout << std::endl;

	}

	return 0;
}

#undef IARR_LENGTH
#undef DARR_LENGTH

